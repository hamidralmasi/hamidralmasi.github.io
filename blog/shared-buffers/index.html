<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">

		
		<link rel="shortcut icon" href="https://hamidralmasi.github.io/images/fav/favicon.ico" />
		<link rel="icon" sizes="64x64 32x32 24x24 16x16" href="https://hamidralmasi.github.io/images/fav/favicon.ico">
		<link rel="apple-touch-icon-precomposed" href="https://hamidralmasi.github.io/images/fav/favicon-152.png">

		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="generator" content="Hugo 0.88.1" />

		
		
		

		
		<link rel="preconnect"
			href="https://fonts.gstatic.com"
			crossorigin />
		<link rel="preconnect"
			href="https://use.fontawesome.com"
			crossorigin />

		
		<link rel="preload"
			as="style"
			href="https://fonts.googleapis.com/css?family=Alegreya:400,400i,700,700i&display=swap" />

		
		<link rel="stylesheet"
			href="https://fonts.googleapis.com/css?family=Alegreya:400,400i,700,700i&display=swap"
			media="print" onload="this.media='all'" />

		
		<noscript>
			<link rel="stylesheet"
				href="https://fonts.googleapis.com/css?family=Alegreya:400,400i,700,700i&display=swap" />
		</noscript>

		
		<link href="https://use.fontawesome.com/releases/v5.0.6/css/all.css" rel="stylesheet">

		
		<link rel="stylesheet" href="https://hamidralmasi.github.io/css/base-min.css" crossorigin="anonymous">
		<link rel="stylesheet" href="https://hamidralmasi.github.io/css/grids-min.css" crossorigin="anonymous">
		<link rel="stylesheet" href="https://hamidralmasi.github.io/css/grids-responsive-min.css" crossorigin="anonymous">

		<style type="text/css">
			html {
				line-height: 1.35;
			}

			html, button, input, select, textarea, .pure-g [class *= "pure-u"] {
				font-family: "Alegreya", "Lora", Georgia, Times, "Times New Roman", serif;
			}

			@font-face {
				font-family: "Georgia";
				font-display: fallback;
				src: local(Georgia);
			}
		</style>

		

		

		

		<link rel="stylesheet" href="https://hamidralmasi.github.io/css/styles.css">
		<link rel="stylesheet" href="https://hamidralmasi.github.io/css/small.css" media="(min-width: 23em)">
		<link rel="stylesheet" href="https://hamidralmasi.github.io/css/medium.css" media="(min-width: 48em)">
		<link rel="stylesheet" href="https://hamidralmasi.github.io/css/large.css" media="(min-width: 64em)">
		<link rel="stylesheet" href="https://hamidralmasi.github.io/css/custom.css">

		
		<title>(Almost) Lockless Stream Buffering - Hamidreza Almasi</title>
		<meta property='og:title' content="(Almost) Lockless Stream Buffering - Hamidreza Almasi">
		<meta property="og:type" content="article">
		

		<meta property="og:url" content="https://hamidralmasi.github.io/blog/shared-buffers/">
		<meta name="description" content="Portfolio and personal blog site of Hamidreza Almasi.">
		
		
		<meta property="og:image" content="https://hamidralmasi.github.io//blog/shared-buffers/images/header_hucfada73cb02bc684a3ef7042da3fa0f5_3470268_200x0_resize_q100_box.png">
		
		<meta name="author" content="Hamidreza Almasi" />

		





	
	
	
	


<script type="application/ld+json">
	{
		"@context": "http://schema.org",
		"@type": "BlogPosting",
		"mainEntityOfPage":{
			"@type":"WebPage",
			"@id":"https:\/\/hamidralmasi.github.io\/"
		},
		"headline": "(Almost) Lockless Stream Buffering |  ",

		
		
		"image": [
			
			{
				"@type": "ImageObject",
				"url": "https:\/\/hamidralmasi.github.io\/blog\/shared-buffers\/images\/header.JPG",
				"height": 700,
				"width": 700,
				"caption": "Japanese pond and stream at the UC Berkeley Botanical Gardens."
			}
			
		]
		

		"datePublished": "2020-04-27T00:00:00JST",
		"dateModified": "2020-04-27T00:00:00JST",
		"author": {
			"@type": "Person",
			"name": "Hamidreza Almasi",
			"image": "https:\/\/hamidralmasi.github.io\/images/profile.jpg"
		},
		"publisher": {
			"@type": "Organization",
			"name": "",
			"logo": {
				"@type": "ImageObject",
				"url": "https:\/\/hamidralmasi.github.io\/images/logo.png",
				"height": 60,
				"width": 60
			}
		},
		"description": "Sharing (and saving) bytestreams effectively."
	}
</script>

<script type="text/javascript">
	function newSmallWindow(url) {
		window.open(url, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes');
		return false;
	}
</script>

<link rel="bookmark" href="https://hamidralmasi.github.io/blog/shared-buffers/" />

</head>
<body class="pure-g">

<nav class="navbar pure-u-1 pure-u-md-1-4">
	<div class="navbar-header">
		<a href="https://hamidralmasi.github.io/">Hamidreza Almasi</a>
	</div>

	<div class="navbar-split"></div>

	
	<div class="navbar-body">
		<div class="navbar-body-buffer pure-g">
		
			
			<div class="pure-u-1-3 pure-u-md-1"><a href="https://hamidralmasi.github.io/blog/" >blog</a></div>
			
			<div class="pure-u-1-3 pure-u-md-1"><a href="https://hamidralmasi.github.io/project/" >projects</a></div>
			
			<div class="pure-u-1-3 pure-u-md-1"><a href="https://hamidralmasi.github.io/CV_Hamid.pdf" >CV</a></div>
			
			<div class="pure-u-1-3 pure-u-md-1"><a href="https://hamidralmasi.github.io/publication/" >publications</a></div>
			
		
		</div>
	</div>

	<div class="navbar-split"></div>

	<section class="social">
	

	
	<a href="http://github.com/hamidralmasi" alt="GitHub" title="GitHub"><i class="fab fa-github"></i></a>
	

	
	<a href="mailto:hamidralmasi@gmail.com" alt="Email" title="Email"><i class="fas fa-envelope"></i></a>
	

	
	<a href="http://twitter.com/hamidralmasi" alt="Twitter" title="Twitter"><i class="fab fa-twitter"></i></a>
	

	

	

	
</section>

</nav>
<div class="content pure-u-1 pure-u-md-3-4">
	<div>

<article class="single">
	<a href="/blog/shared-buffers/images/header.JPG" ><img class="pure-img" style="width: 100%" src="/blog/shared-buffers/images/header_hucfada73cb02bc684a3ef7042da3fa0f5_3470268_600x0_resize_q100_box.png" alt="Japanese pond and stream at the UC Berkeley Botanical Gardens."></img></a>

	<div class="body">
		<h1>(Almost) Lockless Stream Buffering</h1>
		<h4 class="desc">Sharing (and saving) bytestreams effectively.</h4>
		<h3 class="date">
	<time datetime="2020-04-27T00:00:00JST">
		Mon, Apr 27, 2020
	</time>
</h3>
		
<aside class="reading-time">
	<i>Reading time: ~13 minutes.</i>
</aside>

		
<aside class="tag-holder">
	<i>Tags:
	
		<a class="tag" href="https://hamidralmasi.github.io/tags/rust/">Rust</a>
	
		<a class="tag" href="https://hamidralmasi.github.io/tags/discord/">Discord</a>
	
		<a class="tag" href="https://hamidralmasi.github.io/tags/audio/">Audio</a>
	
		<a class="tag" href="https://hamidralmasi.github.io/tags/concurrency/">Concurrency</a>
	
	</i>
</aside>

		<aside class="category-holder">
	
		<div class="categorywrap"><a class="category" href="https://hamidralmasi.github.io/categories/development/">Development</a></div>
	
</aside>
		<div class="post-split"></div>
		<p>Recently, I&rsquo;ve been working on retooling the audio processing code for <a href="https://github.com/serenity-rs/serenity">serenity</a>, a Discord bot library.
Adding features like looping, seeking, and shared resources between calls is made difficult when all input data arrives over pipes from <code>ffmpeg</code> and similar decoders.
Due to this, I&rsquo;ve designed a thread-safe shared stream buffer intended to lock only on accessing and storing new data.</p>
<p>I wanted to write this up mainly because the data structure needs finer-grained control over shared access and locking than Rust can provide.
It requires <code>unsafe</code> code to be expressed performantly, and so demands explanation separate from the audio-specific modifications.
However, I also think the technique could be useful to others.
To keep things simple, I&rsquo;ll describe structs and key fields in code, but leave the algorithmic details to text.</p>
<p>(The actual implementation with many audio-specific modifications <a href="https://github.com/FelixMcFelix/serenity/blob/voice-rework/src/voice/streamer.rs#L622-L1641">can be found here</a> if needed.)</p>
<h2 id="high-level-introduction">High-level introduction</h2>
<p>Before I dive into details, the method essentially works by the following:</p>
<ul>
<li>Handles contain information about their place in the stream, how they are using that stream, and a reference to a shared store.</li>
<li>New data is placed into a rope of byte segments.</li>
<li>Threads only ever lock once they try to read <em>past</em> the current stored length. <a href="#the-critical-section">This is safe for various reasons</a>.</li>
<li>On stream completion, all rope segments are copied into a single buffer.</li>
<li>Reads from a finished stream come from a single, contiguous block of data.</li>
</ul>
<p>Reading from this store can be condensed down to the following algorithm pseudocode:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Assume we know how many bytes are</span>
<span style="color:#75715e"># currently stored as backing_len</span>

<span style="color:#75715e"># main method: reads bytes from stream into buf transparently</span>
<span style="color:#75715e"># from pos, where reads last came from location.</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">read</span>(pos, location, buf):
	atomic(stream_done <span style="color:#f92672">=</span> finalised, acquire)

	<span style="color:#66d9ef">if</span> stream_done:
		promote handle location to use backing store
	
	atomic(available <span style="color:#f92672">=</span> backing_len, acquire)
	<span style="color:#66d9ef">if</span> stream_done <span style="color:#f92672">or</span> read <span style="color:#f92672">is</span> <span style="color:#f92672">in</span> stored region:
		read_amt <span style="color:#f92672">=</span> min(buf<span style="color:#f92672">.</span>len, available <span style="color:#f92672">-</span> pos)
		local_read(pos, location, buf, read_amt)
	<span style="color:#66d9ef">else</span>:
		read <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
		<span style="color:#66d9ef">while</span> read <span style="color:#f92672">!=</span> buf<span style="color:#f92672">.</span>len <span style="color:#f92672">or</span> (stream_done
				<span style="color:#f92672">and</span> available <span style="color:#f92672">==</span> pos <span style="color:#f92672">+</span> read):
			<span style="color:#75715e"># Note: any thread may change backing_len</span>
			<span style="color:#75715e"># at any time.</span>
			atomic(available <span style="color:#f92672">=</span> backing_len, acquire)

			space <span style="color:#f92672">=</span> available <span style="color:#f92672">-</span> pos <span style="color:#f92672">-</span> read

			<span style="color:#66d9ef">if</span> space <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
				acquire lock
				recalculate space

				<span style="color:#66d9ef">if</span> space <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
					fill_from_source(buf<span style="color:#f92672">.</span>len <span style="color:#f92672">-</span> read)
					recalculate space
					<span style="color:#66d9ef">try</span> to promote location

				<span style="color:#75715e"># No action if there are now</span>
				<span style="color:#75715e"># available bytes, read those instead.</span>

				drop lock

			<span style="color:#66d9ef">if</span> space <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
				local_read(pos <span style="color:#f92672">+</span> read, location,
					buf[read<span style="color:#f92672">..</span>], space)

			atomic(stream_done <span style="color:#f92672">=</span> finalised, acquire)

<span style="color:#75715e"># move some bytes into the target buffer, either</span>
<span style="color:#75715e"># from the rope or single store</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">local_read</span>(pos, location, buf, count):
	<span style="color:#66d9ef">if</span> location <span style="color:#f92672">is</span> backing store:
		read <span style="color:#f92672">from</span> backing_store[pos<span style="color:#f92672">..</span>] into buf
	<span style="color:#66d9ef">else</span>:
		walk rope until segment containing pos
		fill buf using segment[pos<span style="color:#f92672">-</span>seg_start<span style="color:#f92672">..</span>]
		count <span style="color:#f92672">-=</span> amount of bytes read
		repeat on next segments until count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>

<span style="color:#75715e"># add new bytes to rope, possibly finalise</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fill_from_source</span>(to_add):
	remaining <span style="color:#f92672">=</span> to_add
	<span style="color:#66d9ef">while</span> remaining <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> stream <span style="color:#f92672">not</span> done:
		<span style="color:#66d9ef">if</span> no space <span style="color:#f92672">in</span> last segment:
			append new segment to rope
		<span style="color:#66d9ef">else</span>:
			read bytes <span style="color:#f92672">from</span> stream
			to_add <span style="color:#f92672">-=</span> amount of bytes read

			<span style="color:#75715e"># allow other streams to access these bytes</span>
			<span style="color:#75715e"># without lock</span>
			atomic(backing_len <span style="color:#f92672">+=</span> amount of bytes read, release)

	<span style="color:#75715e"># finalisation</span>
	<span style="color:#66d9ef">if</span> stream <span style="color:#f92672">is</span> done:
		allocate large buffer of size backing_len
		<span style="color:#66d9ef">for</span> el <span style="color:#f92672">in</span> rope:
			copy el into buffer[el<span style="color:#f92672">.</span>start_pos<span style="color:#f92672">..</span>]
		atomic(finalised <span style="color:#f92672">=</span> true, release)

</code></pre></div><p>At a high level, I hope that this is relatively simple.
In practice, of course, implementing this safely and decently complicates matters.
Now we can get into trickier details of an actual implementation; most of what follows discusses this in the context of Rust.</p>
<h2 id="functional-requirements">Functional requirements</h2>
<p>Why should we implement the above in the first place?
Due to our heavy use of <code>youtube-dl</code>, <code>ffmpeg</code>, and other external streaming audio converters, we have a <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem">Readers-Writers problem</a> with the following constraints:</p>
<ul>
<li>Convert a stream into an in-memory, seekable representation.</li>
<li>Allow safe, shared access to the stored bytestream by many handles.</li>
<li>Reads past the end of the buffer access an underlying <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> object, and new data must be stored for other handles to access.</li>
<li>Minimal locking: no read to an already buffered segment should require a lock.</li>
<li>Make only small, piecewise allocations (without reallocation).</li>
</ul>
<p>To meet these goals, we require that each handle has shared mutable access to the byte source and storage.
Due to the nature of the critical section, we need to take control of (im)mutability checking ourselves and assure the compiler that what we&rsquo;re doing is, in fact, sound:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SharedStore</span> {
    raw: <span style="color:#a6e22e">UnsafeCell</span><span style="color:#f92672">&lt;</span>RawStore<span style="color:#f92672">&gt;</span>,
}

<span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">impl</span> Send <span style="color:#66d9ef">for</span> SharedStore {}
<span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">impl</span> Sync <span style="color:#66d9ef">for</span> SharedStore {}
</code></pre></div><p>This <em>can</em> be handled by safe code, albeit slowly, and with a lot of starvation.
In the naïve case, shared access of a central buffer can be handled safely by an <a href="https://docs.rs/parking_lot/0.10.2/parking_lot/type.RwLock.html"><code>RwLock</code></a>.
This comes at a cost, however.
Every read requires a read-lock (regardless of whether the stream is finalised), while a single active write-lock prevents <em>all</em> reads, even of data which is known to be safe to access.
Likewise, active readers may prevent new data from being stored.</p>
<h2 id="user-handles">User handles</h2>
<p>Handles require a pointer to the shared store, their current position in the bytestream, and knowledge of which type of internal storage they will be pulling bytes from.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ByteCache</span> {
    core: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>SharedStore<span style="color:#f92672">&gt;</span>,
    pos: <span style="color:#66d9ef">usize</span>,
    loc: <span style="color:#a6e22e">CacheReadLocation</span>,
}

<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">CacheReadLocation</span> {
	Rope(Arc<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>),
    Backed,
}
</code></pre></div><p>All handles know whether they are using a piecemeal, incrementally allocated store (shown below) or a finalised buffer.
As described in the <a href="#high-level-introduction">basic algorithm above</a>, reads inform the <code>ByteCache</code> on whether to upgrade <code>loc</code> from <code>Rope(_)</code> to <code>Backed</code>.
Dropping the <code>CacheReadLocation</code> causes a shared counter to decrement, telling the backing store when it can safely deallocate the rope data structure.
I&rsquo;ll explain why below, but <code>ByteCache</code> must have a custom <code>impl Drop</code> where it attempts to remove the rope from storage, identical to an upgrade operation.</p>
<h2 id="handling-progressive-allocation">Handling progressive allocation</h2>
<p>The key for allocating (and ensuring safe concurrent access) is to employ a <em>rope</em> data structure based on intrusive <a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html"><code>LinkedList</code></a>s.
As more space is required, new segments are allocated progressively.
Since this has an O(n) lookup cost, once the underlying stream finishes all data should be moved to a single contiguous buffer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RawStore</span> {
	len: <span style="color:#a6e22e">AtomicUsize</span>,
	finalised: <span style="color:#a6e22e">AtomicBool</span>,

	backing_store: Option<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>,
	rope: Option<span style="color:#f92672">&lt;</span>Arc<span style="color:#f92672">&lt;</span>LinkedList<span style="color:#f92672">&lt;</span>Chunk<span style="color:#f92672">&gt;&gt;&gt;</span>,
	rope_users: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>,
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Chunk</span> {
    data: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>,
    start_pos: <span style="color:#66d9ef">usize</span>,
}
</code></pre></div><p>The cache&rsquo;s <code>rope</code> is initialised based on either a length hint (if available), or an empty chunk of length <code>chunk_len</code>.
As more capacity is required, new chunks of length <code>chunk_len</code> are added to the back.
Once the underlying <code>Read</code> object returns <code>Ok(0)</code> or any error which isn&rsquo;t <code>Interrupted</code>, we know that the stream has ended, and may initialise and populate the backing store using chunk data (while preventing any reads which exceed <code>len</code>).</p>
<p>Installing the backing store efficiently is considerably more <code>unsafe</code> if we only have one chunk, because we can now include a new optimisation.
Optimal behaviour (no copies and no new allocations) requires that we temporarily alias the <code>Vec&lt;u8&gt;</code> between the <code>rope</code> and <code>backing_store</code>.
While it is safe to reconstruct a new <code>Vec</code> from identical parts (and we are certain that the new <code>Vec</code> has an identical lifetime because it never leaves the <code>RawStore</code>), we&rsquo;ve set up a contract where the rope <code>Vec</code>&rsquo;s heap buffer must be leaked rather than dropped by the program to prevent a double free.</p>
<h3 id="management">Management</h3>
<p>This brings us onto how we actually manage the life-cycle of these rope structures.
Even if the data structure is finalised, the <code>rope</code> must remain alive so long as any handle could still be reading from it: <code>CacheReadLocation::Rope(_)</code> is a strong reference to <code>rope_users</code>, which we&rsquo;ll be using as a sentinel for this purpose.
On <code>Drop</code> or upgrade of a <code>ByteCache</code>, the store checks whether only one reference remains, and attempts to acquire the lock.</p>
<ul>
<li>If the lock was unavailable, the upgrade happens and the store is unchanged. Because there is always a chance that several handles could be upgraded at the same time, there is a significant risk that many of them could concurrently see a strong count of 1, and attempt to perform the same operation if unguarded.</li>
<li>If the lock is acquired, then the rope is deallocated. In the aliased 1-chunk case, this rope chunk&rsquo;s <code>data</code> store is leaked to keep it alive in <code>backing_store</code>.</li>
</ul>
<p>The <code>impl Drop</code> of <code>ByteCache</code> is particularly important when we choose to alias the data store.
Consider the case where we have many <code>Backed</code> handles, and one <code>Rope</code> handle who never conducts any further reads after finalisation.
When all <code>Backed</code> handles are dropped, if the <code>Rope</code> is dropped afterwards then the handle must decrement the rope counter (by &ldquo;upgrading&rdquo; to <code>Backed</code>) and explicitly forget one instance of the aliased <code>Vec</code> to prevent a double free.</p>
<h3 id="design-choices">Design choices</h3>
<p>Given all the talk of performance, the choice of a <a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html"><code>LinkedList</code></a> rather than a <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a> will probably seem strange to most people.
Isn&rsquo;t <code>VecDeque</code> a faster choice, recommended by the standard library?
Once again, it comes down to granularity of control when we need to add additional elements.
While <code>VecDeque</code> offers O(1) lookup, insertion can very well trigger a full reallocation as the length hint may be incorrect, when the <code>Vec</code>-backed list runs out of capacity and resizes.
Beyond the obvious cost of a full copy on every reallocation, this will also invalidate references to the list of <code>Chunk</code>s.
This forces the use of a either an <code>RwLock</code> around the rope (leading to the aforementioned lock costs and starvation risks), or <code>Arc</code>ing every <code>Chunk</code> at the cost of extra indirection and the overhead of reference counting.</p>
<p>Separating the <code>Arc</code> from the data it concerns, while unorthodox, serves a few purposes:</p>
<ul>
<li>Nullifying a layer of indirection,</li>
<li>Preventing us from needing another <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a> to share mutability of the list,</li>
<li>Still ensures automatic decrement on drop.</li>
</ul>
<h2 id="the-critical-section">The critical section</h2>
<p>The critical section concerns a few key operations, and is triggered in only two situations: adding new bytes to the store, or deallocating the rope.
These operations are:</p>
<ul>
<li>Modifying the stored length,</li>
<li>Adding new chunks to the rope,</li>
<li>Modifying or reading from the underlying byte source (and any encoder/stream transformation state),</li>
<li>Removal and deallocation of the rope.</li>
</ul>
<p>Because many of these involve modifying state which other threads will be reading, I&rsquo;ll walk through the most natural observations.</p>
<h3 id="how-do-we-know-its-safe-to-access-len-even-if-its-being-written-to-by-another-thread">How do we know it&rsquo;s safe to access <code>len</code> even if it&rsquo;s being written to by another thread?</h3>
<p>At any point, <code>len</code> states that the backing store contains <em>at least that many bytes</em>.
By design, the bytestream will never be modified once stored, so reads are guaranteed to be consistent and valid up to <code>len</code>.
Additionally, modifications to <code>len</code> will only ever increase its value, so bytes which are valid to read will always remain valid.
A handle may not be able to fill its buffer in one call, but it <em>will</em> attempt reading/storage until the output buffer is filled or the stream finishes.
In the event that neither condition is met, the handle either adds more bytes itself or blocks until more are available.</p>
<h3 id="how-can-multiple-handles-safely-walk-a-linked-list-under-modification">How can multiple handles safely walk a linked list under modification?</h3>
<p>Because the start and end of the region to be read from the rope depend only on <code>RawStore.len</code>, and not on any <code>Chunk</code>&rsquo;s <code>data.len()</code>, we know that no modifications to a <code>Chunk</code>&rsquo;s store data length will affect the bytes we want to read.
Equally, we know that adding new data to <code>Chunk</code>s will never cause a reallocation or change <code>start_pos</code>, only a modifying the length value of the tail node.
Accessing the referred data is then always safe, because the segment buffer pointers will not change.
As far as access to the list itself is concerned, new chunks only change the tail pointer and the next pointer in the prior tail element, while all walking/iteration occurs from the front of the list.</p>
<p>Finding the correct <code>Chunk</code> relies upon both <code>start_pos</code> and <code>data.len()</code> for every rope element.
<code>Chunk</code>s which aren&rsquo;t at the tail of the rope are guaranteed to remain unchanged.
When new bytes are being stored in the tail element of the list, the <code>Vec</code> is resized to match its capacity, bytes are read in, and the <code>Vec</code> is resized to match the true written amount.
As <code>len</code> is incremented after the buffer shrinks to its true size, no invalid bytes may be accessed, so the tail element&rsquo;s length will never decrease below the value it had when <code>len</code> was last observed.
However, the amount of bytes from <code>pos</code> that a handle wishes to read is computed using <code>len</code> &ndash; while more bytes or chunks could have been stored in the interim, accesses to existing data aren&rsquo;t invalidated.</p>
<h3 id="atomic-control-of-length">Atomic control of length</h3>
<p>On standard x86-64 systems, we can be certain that size-aligned writes/reads of primitive data are bound to be atomic.
However, this cannot be guaranteed on all classes of CPU.
Furthermore, the compiler and CPU are both capable of heavily reordering the code we write to the point that safety is violated: <a href="https://doc.rust-lang.org/nomicon/atomics.html">the nomicon runs through this in detail</a>.
Given the correctness of this algorithm relies upon stored length being updated <em>only after new data are written</em>, we need to apply atomics here to inform the compiler and CPU that this order must be respected.
In the initial algorithm, we store <code>backing_len</code> using <code>Ordering::Release</code> to ensure that no writes (<em>i.e.</em>, to the rope) are moved beyond setting <code>backing_len</code>, and read <code>backing_len</code> using <code>Ordering::Acquire</code> to ensure that data reads only occur after a safe length value is read (thanks, /u/usinglinux and /u/matthieum).</p>
<p>The same semantics must be applied to <code>finalised</code>.
Although <code>std::mem::sizeof&lt;bool&gt;()</code> is defined as 1-byte, and so is always aligned on all platforms (with writes which cannot be subdivided), writes to the contiguous store must occur before the cache is finalised.
The same orderings for loads/stores are used as above.</p>
<h2 id="further-improvements">Further improvements</h2>
<p>There are some additional changes and modifications which can be made depending on the use case, or for blanket performance improvements.</p>
<ul>
<li>Spawn a new thread for finalisation.
<ul>
<li>This ensures that the thread which finishes a stream doesn&rsquo;t hold up the caller, but slightly complicates the logic for preventing reads past <code>backing_len</code>.</li>
</ul>
</li>
<li>Subtraction on atomics to remove the rope, rather than relying upon an <code>Arc</code>.
<ul>
<li>We lose the automatic decrement on drop, but since we have a custom <code>impl Drop</code> the mechanisms are very similar.</li>
<li>Most importantly, this removes the need to lock because it&rsquo;s immediately clear (through <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html#method.fetch_sub"><code>fetch_sub</code></a>) which handle was responsible for reducing the reference count from 2 to 1.</li>
</ul>
</li>
<li>Store pointers to rope elements in handles, to prevent walking the rope on every access before finalisation.
<ul>
<li>Unfortunately, this requires more <code>unsafe</code> code.
We know that it <em>is</em> safe to store such pointers given that <code>Chunk</code>s will never move, such pointers would be contained in a <code>Chained</code> (and thus remain live as long as the referred rope), and control shared mutable access in the same manner.</li>
<li>Currently, this is blocked on <a href="https://github.com/rust-lang/rust/issues/58533">LinkedList cursors</a> stabilising, or moving to an external library such as <a href="https://docs.rs/intrusive-collections/">Amanieu&rsquo;s intrusive collections</a>.
Standard library <code>IterMut</code>s store the list&rsquo;s length at their time of creation, and will not proceed past this point.</li>
</ul>
</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Thanks for reading!
Hopefully, this has given you some useful insight into solving this particular concurrent buffering problem and how we&rsquo;re solving it.
I&rsquo;m unsure whether the above has been documented elsewhere: if you know, please feel free to <a href="mailto:kyleandrew.simpson@gmail.com">contact me</a>.
Likewise, if there corrections to be made feel free to request any changes on <a href="https://github.com/felixmcfelix/mcfelix.me">GitHub</a>.</p>
<p>EDIT: Following <a href="https://www.reddit.com/r/rust/comments/g8qgkj/almost_lockless_stream_buffering/">the discussion on Reddit</a>, /u/usinglinux and /u/matthieum&rsquo;s advice on atomics around the backing length has been included.
/u/matthiuem contributed <a href="https://www.reddit.com/r/rust/comments/g8qgkj/almost_lockless_stream_buffering/foq8twl/">an excellent single-writer lockless approach</a>.</p>
	</div>

	<aside>
	<section>
		<div class="social share">
			<a
				href="https://hamidralmasi.github.io/blog/shared-buffers/" 
				onclick="window.open(this.href, '_blank'); return false;"
				alt="Permalink"
				title="Permalink"
			><i class="fas fa-link"></i></a>

			<a
				href="http://www.facebook.com/sharer.php?src=bm&u=https%3a%2f%2fhamidralmasi.github.io%2fblog%2fshared-buffers%2f&t=%28Almost%29%20Lockless%20Stream%20Buffering"
				onclick="return newSmallWindow(this.href);"
				alt="Share on Facebook"
				title="Share on Facebook"
			><i class="fab fa-facebook"></i></a>

			<a
				href="http://twitter.com/intent/tweet?url=https%3a%2f%2fhamidralmasi.github.io%2fblog%2fshared-buffers%2f&text=%28Almost%29%20Lockless%20Stream%20Buffering&tw_p=tweetbutton"
				onclick="return newSmallWindow(this.href);"
				alt="Share on Twitter"
				title="Share on Twitter"
			><i class="fab fa-twitter"></i></a>

			<a
				href="http://getpocket.com/edit?url=https%3a%2f%2fhamidralmasi.github.io%2fblog%2fshared-buffers%2f&title=%28Almost%29%20Lockless%20Stream%20Buffering"
				onclick="return newSmallWindow(this.href);"
				alt="Save to Pocket"
				title="Save to Pocket"
			><i class="fab fa-get-pocket"></i></a>
		</div>
	</section>
</aside>

</article>

				<footer>
					<p>&copy; 2021 Hamidreza Almasi</p>
					<p>Powered by <a href="http://gohugo.io" target="_blank" rel="noreferrer">Hugo</a>.</p>
				</footer>
			</div>
		</div>
	</body>
</html>